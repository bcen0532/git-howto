# Gitの使い方


## gitを使った作業の流れ

    1. gitのリポジトリをクローン or 作成する
    2. リモートの最新の変更に追従する
    3. 変更内容を(ローカルに)コミットする
    4. リモートに送信する


## svnとの違い

gitはsvnや他のバージョン管理システムとは大きく異なります。

- 差分ではなく全部保存する

- ローカルに全ての履歴がある

結果、ブランチの統合や切り替えがスマートにでき、バージョン管理も効率的に出来ます。


コマンドを最初から色々覚えるより、変更をかけながらリポジトリの中を見たほうが早いので、
本稿では都度リポジトリ内部を見ていきます。


## リポジトリの作成


### 新たなローカルリポジトリを作る

まずプロジェクトのローカルリポジトリを作ります。


```
svnと違い、ローカルで作業をコミットした後、権限があればリモート（サーバー側）に送信(push)する形になります。
権限がない場合、自分のリポジトリを取って(pull)来て変更をマージしてくれ、とリモート側に頼むことになります。
これがGitHubなどでよく聞かれるpull requestです。
```

仮にプロジェクトディレクトリをtestとすると以下のようにしてプロジェクトのリポジトリを作成します。

> $ mkdir test
> $ cd test
> $ git init

上の様にすると、testディレクトリ内に.git/ディレクトリが作られます。ここがリポジトリ本体になります。

gitで管理するファイル・履歴・ブランチなどは全てここに格納されています。
逆に言うとこの.git以下をコピーするとそれだけでリポジトリ全体をコピーできます。


#### ローカルリポジトリにリモートを登録する

送信したいリポジトリのアドレスを指定します。

> $  git remote add origin <url>

もしくは.git/configをエディタで編集します。


##### サーバー側にリポジトリがない場合

管理方法によって異なりますが、基本的に手動で空リポジトリを作ることになります。

> $

その後、git remote add origin <url>でリポジトリのアドレスを指定します。


### リモートからローカルにリポジトリをクローンする

リポジトリをクローンする場合には、

> $ git clone <url or path>

とすればリポジトリ(.git)以下が丸々ローカルにコピーされ、最新のファイルがチェックアウトされます。

この場合すでにリモートのurlが登録済みですので、push時に自動で元urlにpushされます。


## ファイルを追加する

### 通常のファイル

gitのリポジトリにファイルを追加する場合、

> $ git add hoge.txt

とします。実はこの時点ですでにファイルはリポジトリ内に格納されています。

> $ ls -la .git/objects/

とすると内容が追加されているのがわかります。
これはzlibでhoge.txtを圧縮したものです。


#### オブジェクト・データベース

hogehogeと言う名前はファイルの中身を圧縮後、ハッシュ関数(SHA1で)求めた文字列で、ファイル名とファイル内容から
（現実的には）一意に求まります。

アクセスを高速にするため、gitでは先頭2文字をディレクトリ名、残りをファイル名として分類しています。

例えばPATHが .git/objects/a1/aa7e068eb84044ab2e064eacb105aa1c9a23d1の場合、

> $ git cat-file -p a1aa7e068eb84044ab2e064eacb105aa1c9a23d1

とすると、 hoge.txtの内容が格納されていることがわかります。


#### カレント・ディレクトリ・キャッシュ

また、.git/indexと言うファイルが作成されています。

以下の様にしてindexの内容を確認出来ます。

> $ git ls-files --stage
> 100644 e9bc11025c28829eedf6d30cd3b65628648cad5f 0       hoge.txt

と、今一つのファイルがリポジトリに登録されていることがわかりました。

このindexはカレントディレクトリキャッシュで現在作業中のデータに高速にアクセス
するためのものです。

また、コミット時にはこの内容が使用されます。


#### 追加の取り消し

indexへの追加の取り消しは以下のようにします。
git resetはコミットを以前の状態に戻すためのものです。

HEADは、現在最新のコミットを指します。

> $ git reset HEAD hoge.txt


### ディレクトリファイル

ディレクトリも同じ様にしてgitリポジトリに追加できます。
仮にhoge-dirと言う

> $ git add hoge-dir
> $ git ls-files --stage

> 100644 a51f72110d06dcfb1b10e0193cec27e03e9b9829 0       hoge-dir/hoge2.txt
> 100644 a8f170b4ff85bd72a203fb2d2b857518f7be23d6 0       hoge-dir/hoge3.txt
> 100644 e9bc11025c28829eedf6d30cd3b65628648cad5f 0       hoge.txt


## コミット
追加したファイルをコミットします。

> $ git commit

するとエディタが立ち上がるので、メッセージを編集して保存するとコミットされます。

> This is First Commit
> # Please enter the commit message for your changes. Lines starting
> # with '#' will be ignored, and an empty message aborts the commit↲
> #
> # On branch master
> #
> # Initial commit
> #
> # Changes to be committed:
> #>......new file:   hoge-dir/hoge2.txt
> #>......new file:   hoge-dir/hoge3.txt
> #>......new file:   hoge.txt
> #

#### gitでのコミットの意味

git addの段階でファイルはすでに.git/objects/以下にオブジェクトとして登録されているので、
実際にコミットした時に登録されるのは何をコミットしたのか、というメタ情報になります。

git logでコミットの履歴を確認します。
--graphオプションはブランチのツリーをグラフィカルに表示してくれます。

> $ git log --graph
> commit 7ca0d6ce54d06122235064286cd3eb286bea492b (HEAD -> master)
> Author: takuma udagawa <udagawa@bcen.co.jp>
> Date:   Thu Nov 2 14:47:33 2017 +0900
>
>    This is First Commit
>


この '7ca0d6ce54d06122235064286cd3eb286bea492b'というのがコミットを一意に特定する値です。
これはこのコミットにはどのオブジェクトが含まれているかをリスト化したものです。

gitのコミットとは単にこのリスト（現在のディレクトリに含まれているファイルの一覧）を
生成するだけの作業です。

このコミット自体オブジェクトであり、.git/object以下に圧縮されて格納されています。
git cat-fileで表示出来ます。

> $ git cat-file -p 7ca0d6ce54d06122235064286cd3eb286bea492b
> tree 41f882bd3d52ab27d29281fee9c4370e54068228
> author takuma udagawa <udagawa@bcen.co.jp> 1509601653 +0900
> committer takuma udagawa <udagawa@bcen.co.jp> 1509601653 +0900
>
> This is First Commit

tree 41f882bd3d52ab27d29281fee9c4370e54068228というオブジェクトがあります。
更にこれを表示すると、

> $ git cat-file -p 41f882bd3d52ab27d29281fee9c4370e54068228
> 040000 tree 13e71a11b2599e02e507033efd8069e60ccc37d5    hoge-dir
> 100644 blob e9bc11025c28829eedf6d30cd3b65628648cad5f    hoge.txt

含まれているファイルの一覧が表示されます。

さらにここからファイルの内容を辿っていくことができます。

後述するブランチの機能も同じようにオブジェクトファイルの参照で実装されています。

このように、gitでは全てのファイル/履歴は.git/objects以下に圧縮されています。

また、2回目以降のcommitには親コミットの情報も記されます。
これによりgitは数珠つなぎのようにコミットとファイルの履歴をたどることが出来ます。


#### HEADの移動

.git/HEADが書き換わります。
これは現在作業しているのがどのブランチなのかを指すポインタです。
refs/ブランチ名にブランチの先頭のオブジェクトが格納されています。


## ファイルを削除する

現在の


> $ git rm hoge.txt

git rmにより以下の処理が行われます。

index内からhoge.txtへの参照が消され、
ディレクトリ内のhoge.txtファイルが削除されます。

.git/objects/以下にはそのままファイルが残されます。


## ファイルの変更

ファイルの変更を登録にもgit addを使用します。
なぜ変更なのにaddなのか、と言うと、gitは変更前のファイルと変更後のファイルを別物として認識するからです。
(ハッシュ値が違う物は違うオブジェクトとして認識する）。

> $ git add hoge.txt


## ファイルを復元する

> $ git checkout hogehoge.txt


## コミット前の状態に戻す

> $ git reset ^HEAD


## ブランチ

これまで考えてきたのはすべてデフォルトのマスタブランチでの作業でした。
ブランチを分岐させたりマージさせたりする方法について解説します。

### ブランチの一覧を見る


### ブランチを切る

>

### ブランチを選択する

>

### ブランチ同士のマージ

> 

### ブランチを削除する


### リポジトリに含めたくない情報を指定する
.gitignore

.git/exclude

### リモートからPULL

    リモートサーバーにPUSHする

### リモートにPUSH

